---
import Layout from '../layouts/Layout.astro';
import { getCollection } from 'astro:content';
import * as chrono from 'chrono-node';

// React components
import NavbarWithLanguages from '../components/NavbarWithLanguages/index.jsx';
import Agenda from '../components/Agenda/index.jsx';
import News from '../components/News/News.astro';
import Galery from '../components/Galery/index.jsx';

// Astro components
import Hero from '../components/Hero/Hero.astro';
import Quote from '../components/Quote/Quote.astro';
import Biography from '../components/Biography/Biography.astro';
import Footer from '../components/Footer/Footer.astro';

// Global styles
import '../components/reset.css';
import '../components/layout.css';
import '../components/headroom.css';

// Get content collections
const events = await getCollection('events');
const news = await getCollection('news');
const translations = await getCollection('translations');

// Helper function to parse dates using chrono-node like the original version
const parseDate = (dateStr: string | Date): Date => {
  try {
    // If it's already a Date object, return it
    if (dateStr instanceof Date) {
      return dateStr;
    }
    
    // If it's a string, parse it with chrono-node
    if (typeof dateStr === 'string') {
      const parsedDate = chrono.parseDate(dateStr);
      if (!parsedDate) {
        console.warn(`Invalid date: ${dateStr}`);
        return new Date(); // Return current date as fallback
      }
      return parsedDate;
    }
    
    // Fallback for other types
    return new Date();
  } catch (error) {
    console.warn(`Error parsing date: ${dateStr}`, error);
    return new Date(); // Return current date as fallback
  }
};

// Sort events by date (using chrono-node like the original version)
const sortedEvents = events
  .map(event => ({
    ...event,
    data: {
      ...event.data,
      dateTime: parseDate(event.data.dateTime as string) // Parse dateTime using chrono-node
    }
  }))
  .sort((a, b) => a.data.dateTime.getTime() - b.data.dateTime.getTime());

// Get translations and create a proper translations object
const ptTranslationsData = translations.find(t => t.data.title === 'pt')?.data || {};
const enTranslationsData = translations.find(t => t.data.title === 'en')?.data || {};

// Convert translations to flat objects for each language
// Remove the 'title' field and use the rest as translation keys
const { title: ptTitle, ...ptTranslations } = ptTranslationsData;
const { title: enTitle, ...enTranslations } = enTranslationsData;

// Create a translations map with both languages
const allTranslations = {
  pt: ptTranslations,
  en: enTranslations
};

// Default translations (Portuguese)
const translationsObject = ptTranslations;

// Default language for static components  
const currentLanguage = 'pt';

// Initialize stores with server-side data
import { generateInitScript } from '../stores/astro.ts';

// Debug logs (remove in production)
// console.log('Events:', sortedEvents.slice(0, 2));
// console.log('News:', news.slice(0, 2));
---

<Layout title="Jose Eduardo Gomes">
  <div class="Layout">
    <nav class="Layout-navbar">
      <div class="headroom headroom--unfixed">
        <NavbarWithLanguages 
          client:load
          allTranslations={allTranslations}
          isScrolled={false}
        />
      </div>
    </nav>
    <div class="Layout-body">
      <Hero translations={translationsObject} />
      <Agenda client:load translations={translationsObject} events={sortedEvents} />
      <Quote translations={translationsObject} />
      <News translations={translationsObject} news={news} currentLanguage={currentLanguage} />
      <Biography translations={translationsObject} currentLanguage={currentLanguage} />
      <Galery client:load translations={translationsObject} />
      <Footer translations={translationsObject} />
    </div>
  </div>
</Layout>

<script is:inline define:vars={{ 
  initialData: {
    language: currentLanguage,
    translations: allTranslations,
    breakpoint: 'desktop' // Will be updated by client-side detection
  }
}}>
  // Initialize nanostores with server-side data
  import('/src/stores/index.ts').then(({ initializeStores }) => {
    initializeStores(initialData);
  });

  // Headroom scroll behavior
  class Headroom {
    constructor(element) {
      this.element = element;
      this.lastKnownScrollY = 0;
      this.currentScrollY = 0;
      this.direction = 'down';
      this.tolerance = 5;
      this.offset = 50;
      
      this.init();
    }
    
    init() {
      this.bindEvents();
      this.update();
    }
    
    bindEvents() {
      window.addEventListener('scroll', this.onScroll.bind(this));
    }
    
    onScroll() {
      this.currentScrollY = window.pageYOffset;
      this.requestAnimationFrame(this.update.bind(this));
    }
    
    requestAnimationFrame(callback) {
      return window.requestAnimationFrame(callback);
    }
    
    update() {
      const scrolled = this.currentScrollY > this.offset;
      const direction = this.currentScrollY > this.lastKnownScrollY ? 'down' : 'up';
      const toleranceExceeded = Math.abs(this.currentScrollY - this.lastKnownScrollY) >= this.tolerance;
      
      if (this.currentScrollY <= this.offset) {
        // At top of page - show navbar in normal flow
        this.removeClass('headroom--pinned');
        this.removeClass('headroom--unpinned');
        this.removeClass('headroom--scrolled');
        this.addClass('headroom--unfixed');
      } else if (toleranceExceeded && direction !== this.direction) {
        // Direction changed and tolerance exceeded
        this.direction = direction;
        this.removeClass('headroom--unfixed');
        this.addClass('headroom--scrolled');
        
        if (direction === 'down') {
          this.unpin();
        } else {
          this.pin();
        }
      }
      
      this.lastKnownScrollY = this.currentScrollY;
    }
    
    pin() {
      this.removeClass('headroom--unpinned');
      this.addClass('headroom--pinned');
    }
    
    unpin() {
      this.removeClass('headroom--pinned');
      this.addClass('headroom--unpinned');
    }
    
    addClass(className) {
      if (!this.element.classList.contains(className)) {
        this.element.classList.add(className);
      }
    }
    
    removeClass(className) {
      this.element.classList.remove(className);
    }
  }
  
  // Initialize headroom when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const headroomElement = document.querySelector('.headroom');
    if (headroomElement) {
      new Headroom(headroomElement);
    }
  });
</script>
